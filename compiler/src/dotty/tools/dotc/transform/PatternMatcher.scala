package dotty.tools.dotc
package transform

import core._
import TreeTransforms._
import collection.mutable
import SymDenotations._, Symbols._, Contexts._, Types._, Names._, StdNames._, NameOps._
import ast.Trees._
import util.Positions._
import typer.Applications.{isProductMatch, isGetMatch, productSelectors}
import SymUtils._
import Flags._, Constants._
import Decorators._
import patmat.Space
import NameKinds.{UniqueNameKind, PatMatStdBinderName, PatMatCaseName}
import config.Printers.patmatch

/** The pattern matching transform.
 *  After this phase, the only Match nodes remaining in the code are simple switches
 *  where every pattern is an integer constant
 */
class PatternMatcher extends MiniPhaseTransform {
  import ast.tpd._
  import PatternMatcher._

  override def phaseName = "patternMatcher"
  override def runsAfter = Set(classOf[ElimRepeated])
  override def runsAfterGroupsOf = Set(classOf[TailRec]) // tailrec is not capable of reversing the patmat tranformation made for tree

  override def transformMatch(tree: Match)(implicit ctx: Context, info: TransformerInfo): Tree = {
    val translated = new Translator(tree.tpe, this).translateMatch(tree)

    // check exhaustivity and unreachability
    val engine = new patmat.SpaceEngine

    if (engine.checkable(tree)) {
      engine.checkExhaustivity(tree)
      engine.checkRedundancy(tree)
    }

    translated.ensureConforms(tree.tpe)
  }
}

object PatternMatcher {
  import ast.tpd._

  final val selfCheck = true // debug option, if on we check that no case gets generated twice

  /** The pattern matching translator.
   *  Its general structure is a pipeline:
   *
   *     Match tree ---matchPlan---> Plan ---optimize---> Plan ---emit---> Tree
   *
   *  The pipeline consists of three steps:
   *
   *    - build a plan, using methods `matchPlan`, `caseDefPlan`, `patternPlan`.
   *    - optimize the plan, using methods `optimize`, `hoistLabelled`, `referenceCount`.
   *    - emit the translated tree, using methods `emit`, `collectSwitchCases`,
   *      `emitSwitchCases`, and `emitCondition`.
   *
   *  A plan represents the underlying decision graph. It consists
   *  of tests, let and label bindings, calls to labels and code blocks.
   *  It's represented by its own data type. Plans are optimized by
   *  inlining, hoisting, and dead code elimination. We should also
   *  do common test elimination but right now this is missing.
   */
  class Translator(resultType: Type, trans: TreeTransform)(implicit ctx: Context, info: TransformerInfo) {

    // ------- Bindings for variables and labels ---------------------

    /** A map from variable symbols to their defining trees
     *  and from labels to their defining plans
     */
    private val binding = mutable.Map[Symbol, AnyRef/*Tree | Plan*/]()

    /** The defining tree of a variable */
    private def rhs(sym: Symbol) = {
      assert(!sym.is(Label))
      binding(sym).asInstanceOf[Tree]
    }

    /** The plan labelled by a label */
    private def labelled(sym: Symbol) = {
      assert(sym.is(Label))
      binding(sym).asInstanceOf[Plan]
    }

    /** The plan `let x = rhs in body(x)` where `x` is a fresh variable */
    private def letAbstract(rhs: Tree)(body: Symbol => Plan): Plan = {
      val vble = ctx.newSymbol(ctx.owner, PatMatStdBinderName.fresh(), Synthetic | Case,
        sanitize(rhs.tpe), coord = rhs.pos)
      binding(vble) = rhs
      LetPlan(vble, body(vble))
    }

    /** The plan `let l = labelled in body(l)` where `l` is a fresh label */
    private def labelAbstract(labelled: Plan)(body: Plan => Plan): Plan = {
      val label = ctx.newSymbol(ctx.owner, PatMatCaseName.fresh(), Synthetic | Label | Method,
        MethodType(Nil, resultType))
      binding(label) = labelled
      LetPlan(label, body(CallPlan(label)))
    }

    /** Was symbol generated by pattern matcher? */
    private def isPatmatGenerated(sym: Symbol) =
      sym.is(Synthetic) &&
      (sym.is(Label) || sym.name.is(PatMatStdBinderName))

    /** A type map that eliminates all patternmatcher-generated termrefs that
     *  can be replaced by a source-level alias.
     */
    private val sanitize = new TypeMap {
      def apply(t: Type): Type = t.widenExpr match {
        case t: TermRef if isPatmatGenerated(t.symbol) =>
          t.info.widenExpr match {
            case t1: TermRef => apply(t1)
            case _ => t
          }
        case t => mapOver(t)
      }
    }

    // ------- Plan and test types ------------------------

    /** Counter to display plans nicely, for debugging */
    private var nxId = 0

    /** The different kinds of plans */
    sealed abstract class Plan { val id = nxId; nxId += 1 }

    case class TestPlan(test: Test, var scrutinee: Tree, pos: Position,
                        var onSuccess: Plan, var onFailure: Plan) extends Plan
    case class LetPlan(sym: TermSymbol, var body: Plan) extends Plan
    case class CodePlan(var tree: Tree) extends Plan
    case class CallPlan(label: TermSymbol) extends Plan

    object TestPlan {
      def apply(test: Test, sym: Symbol, pos: Position, ons: Plan, onf: Plan): TestPlan =
        TestPlan(test, ref(sym), pos, ons, onf)
    }

    /** The different kinds of tests */
    sealed abstract class Test
    case class TypeTest(tpt: Tree) extends Test                   // scrutinee.isInstanceOf[tpt]
    case class EqualTest(tree: Tree) extends Test                 // scrutinee == tree
    case class LengthTest(len: Int, exact: Boolean) extends Test  // scrutinee (== | >=) len
    case object NonEmptyTest extends Test                         // !scrutinee.isEmpty
    case object NonNullTest extends Test                          // scrutinee ne null
    case object GuardTest extends Test                            // scrutinee

    // ------- Generating plans from trees ------------------------

    /** A set of variabes that are known to be not null */
    private val nonNull = mutable.Set[Symbol]()

    /** A conservative approximation of which patterns do not discern anything.
      * They are discarded during the translation.
      */
    private object WildcardPattern {
      def unapply(pat: Tree): Boolean = pat match {
        case Typed(_, tpt) if tpt.tpe.isRepeatedParam => true
        case Bind(nme.WILDCARD, WildcardPattern()) => true // don't skip when binding an interesting symbol!
        case t if isWildcardArg(t)                 => true
        case x: BackquotedIdent                    => false
        case x: Ident                              => x.name.isVariableName
        case Alternative(ps)                       => ps.forall(unapply)
        case EmptyTree                             => true
        case _                                     => false
      }
    }

    private object VarArgPattern {
      def unapply(pat: Tree): Option[Tree] = swapBind(pat) match {
        case Typed(pat1, tpt) if tpt.tpe.isRepeatedParam => Some(pat1)
        case _ => None
      }
    }

    /** Rewrite (repeatedly) `x @ (p: T)` to `(x @ p): T`
     *  This brings out the type tests to where they can be analyzed.
     */
    private def swapBind(tree: Tree): Tree = tree match {
      case Bind(name, pat0) =>
        swapBind(pat0) match {
          case Typed(pat, tpt) => Typed(cpy.Bind(tree)(name, pat), tpt)
          case _ => tree
        }
      case _ => tree
    }

    /** Plan for matching `scrutinee` symbol against `tree` pattern */
    private def patternPlan(scrutinee: Symbol, tree: Tree, onSuccess: Plan, onFailure: Plan): Plan = {

      /** Plan for matching `selectors` against argument patterns `args` */
      def matchArgsPlan(selectors: List[Tree], args: List[Tree], onSuccess: Plan): Plan =
        args match {
          case arg :: args1 =>
            val selector :: selectors1 = selectors
            letAbstract(selector)(
              patternPlan(_, arg, matchArgsPlan(selectors1, args1, onSuccess), onFailure))
          case Nil => onSuccess
        }

      /** Plan for matching the sequence in `seqSym` against sequence elements `args`.
       *  If `exact` is true, the sequence is not permitted to have any elements following `args`.
       */
      def matchElemsPlan(seqSym: Symbol, args: List[Tree], exact: Boolean, onSuccess: Plan) = {
        val selectors = args.indices.toList.map(idx =>
          ref(seqSym).select(nme.apply).appliedTo(Literal(Constant(idx))))
        TestPlan(LengthTest(args.length, exact), seqSym, seqSym.pos,
          matchArgsPlan(selectors, args, onSuccess), onFailure)
      }

      /** Plan for matching the sequence in `getResult` against sequence elements
       *  and a possible last varargs argument `args`.
       */
      def unapplySeqPlan(getResult: Symbol, args: List[Tree]): Plan = args.lastOption match {
        case Some(VarArgPattern(arg)) =>
          val matchRemaining =
            if (args.length == 1)
              patternPlan(getResult, arg, onSuccess, onFailure)
            else {
              val dropped = ref(getResult)
                .select(defn.Seq_drop.matchingMember(getResult.info))
                .appliedTo(Literal(Constant(args.length - 1)))
              letAbstract(dropped) { droppedResult =>
                patternPlan(droppedResult, arg, onSuccess, onFailure)
              }
            }
          matchElemsPlan(getResult, args.init, exact = false, matchRemaining)
        case _ =>
          matchElemsPlan(getResult, args, exact = true, onSuccess)
      }

      /** Plan for matching the result of an unapply against argument patterns `args` */
      def unapplyPlan(unapp: Tree, args: List[Tree]): Plan = {
        def caseClass = unapp.symbol.owner.linkedClass
        lazy val caseAccessors = caseClass.caseAccessors.filter(_.is(Method))

        def isSyntheticScala2Unapply(sym: Symbol) =
          sym.is(SyntheticCase) && sym.owner.is(Scala2x)

        if (isSyntheticScala2Unapply(unapp.symbol) && caseAccessors.length == args.length)
          matchArgsPlan(caseAccessors.map(ref(scrutinee).select(_)), args, onSuccess)
        else if (unapp.tpe.isRef(defn.BooleanClass))
          TestPlan(GuardTest, unapp, unapp.pos, onSuccess, onFailure)
        else {
          letAbstract(unapp) { unappResult =>
            val isUnapplySeq = unapp.symbol.name == nme.unapplySeq
            if (isProductMatch(unapp.tpe.widen, args.length) && !isUnapplySeq) {
              val selectors = productSelectors(unapp.tpe).take(args.length)
                .map(ref(unappResult).select(_))
              matchArgsPlan(selectors, args, onSuccess)
            }
            else {
              assert(isGetMatch(unapp.tpe))
              val argsPlan = {
                val get = ref(unappResult).select(nme.get, _.info.isParameterless)
                if (isUnapplySeq)
                  letAbstract(get)(unapplySeqPlan(_, args))
                else
                  letAbstract(get) { getResult =>
                    val selectors =
                      if (args.tail.isEmpty) ref(getResult) :: Nil
                      else productSelectors(get.tpe).map(ref(getResult).select(_))
                    matchArgsPlan(selectors, args, onSuccess)
                  }
              }
              TestPlan(NonEmptyTest, unappResult, unapp.pos, argsPlan, onFailure)
            }
          }
        }
      }

      // begin patternPlan
      swapBind(tree) match {
        case Typed(pat, tpt) =>
          TestPlan(TypeTest(tpt), scrutinee, tree.pos,
            letAbstract(ref(scrutinee).asInstance(tpt.tpe)) { casted =>
              nonNull += casted
              patternPlan(casted, pat, onSuccess, onFailure)
            },
            onFailure)
        case UnApply(extractor, implicits, args) =>
          val mt @ MethodType(_) = extractor.tpe.widen
          var unapp = extractor.appliedTo(ref(scrutinee).ensureConforms(mt.paramInfos.head))
          if (implicits.nonEmpty) unapp = unapp.appliedToArgs(implicits)
          val unappPlan = unapplyPlan(unapp, args)
          if (scrutinee.info.isNotNull || nonNull(scrutinee)) unappPlan
          else TestPlan(NonNullTest, scrutinee, tree.pos, unappPlan, onFailure)
        case Bind(name, body) =>
          val body1 = patternPlan(scrutinee, body, onSuccess, onFailure)
          if (name == nme.WILDCARD) body1
          else {
            val bound = tree.symbol.asTerm
            binding(bound) = ref(scrutinee)
            LetPlan(bound, body1)
          }
        case Alternative(alts) =>
          labelAbstract(onSuccess) { ons =>
            (alts :\ onFailure) { (alt, onf) =>
              labelAbstract(onf) { onf1 =>
                patternPlan(scrutinee, alt, ons, onf1)
              }
            }
          }
        case WildcardPattern() =>
          onSuccess
        case _ =>
          TestPlan(EqualTest(tree), scrutinee, tree.pos, onSuccess, onFailure)
      }
    }

    private def caseDefPlan(scrutinee: Symbol, cdef: CaseDef, onFailure: Plan): Plan =
      labelAbstract(onFailure) { onf =>
        var onSuccess: Plan = CodePlan(cdef.body)
        if (!cdef.guard.isEmpty)
          onSuccess = TestPlan(GuardTest, cdef.guard, cdef.guard.pos, onSuccess, onf)
        patternPlan(scrutinee, cdef.pat, onSuccess, onf)
      }

    private def matchPlan(tree: Match): Plan =
      letAbstract(tree.selector) { scrutinee =>
        val matchError: Plan = CodePlan(Throw(New(defn.MatchErrorType, ref(scrutinee) :: Nil)))
        (tree.cases :\ matchError)(caseDefPlan(scrutinee, _, _))
      }

    // ----- Optimizing plans ---------------

    /** Reference counts for all variables and labels */
    private def referenceCount(plan: Plan): collection.Map[Symbol, Int] = {
      val count = new mutable.HashMap[Symbol, Int] {
        override def default(key: Symbol) = 0
      }
      val refCounter = new TreeTraverser {
        def traverse(tree: Tree)(implicit ctx: Context) = tree match {
          case tree: Ident =>
            if (binding contains tree.symbol) count(tree.symbol) += 1
          case _ =>
            traverseChildren(tree)
        }
      }
      def traverse(plan: Plan): Unit = plan match {
        case plan: TestPlan =>
          refCounter.traverse(plan.scrutinee)
          traverse(plan.onSuccess)
          traverse(plan.onFailure)
        case LetPlan(sym, body) =>
          traverse(body)
          if (count(sym) != 0 || !isPatmatGenerated(sym)) {
            binding(sym) match {
              case tree: Tree @unchecked => refCounter.traverse(tree)
              case plan: Plan => traverse(plan)
            }
          }
        case CodePlan(tree) =>
          ;
        case CallPlan(label) =>
          count(label) += 1
      }
      traverse(plan)
      count
    }

    /** Rewrite (repeatedly)
     *
     *    if cond then let caseN = labelled in ons else onf
     *
     *  to
     *
     *    let caseN = labelled in if cond then ons else onf
     *
     *  The rewrite is useful to group cases that can form a switch together.
     */
    private def hoistLabelled(plan: TestPlan): Plan = plan.onFailure match {
      case LetPlan(sym, body) if sym.is(Label) =>
        plan.onFailure = body
        LetPlan(sym, hoistLabelled(plan))
      case _ =>
        plan
    }

    /** Inline let-bound trees and labelled blocks that are referenced only once.
     *  Drop all variables and labels that are not referenced anymore after this.
     *  Also: hoist cases out of tests using `hoistLabelled`.
     */
    private def optimize(plan: Plan): Plan = {
      val refCount = referenceCount(plan)
      val LetPlan(topSym, _) = plan
      def toDrop(sym: Symbol) =
        binding.contains(sym) && isPatmatGenerated(sym) && refCount(sym) <= 1 && sym != topSym
      val treeMap = new TreeMap {
        override def transform(tree: Tree)(implicit ctx: Context) = tree match {
          case tree: Ident =>
            val sym = tree.symbol
            if (toDrop(sym)) transform(rhs(sym)) else tree
          case _ =>
            super.transform(tree)
        }
      }
      def transform(plan: Plan): Plan = plan match {
        case plan: TestPlan =>
          plan.scrutinee = treeMap.transform(plan.scrutinee)
          plan.onSuccess = transform(plan.onSuccess)
          plan.onFailure = transform(plan.onFailure)
          hoistLabelled(plan)
        case plan @ LetPlan(sym, body) =>
          val body1 = transform(body)
          if (toDrop(sym)) body1
          else {
            binding(sym) = binding(sym) match {
              case tree: Tree @unchecked => treeMap.transform(tree)
              case plan: Plan => transform(plan)
            }
            plan.body = body1
            plan
          }
        case plan @ CodePlan(tree) =>
          plan.tree = treeMap.transform(tree)
          plan
        case CallPlan(label) =>
          if (refCount(label) == 1) transform(labelled(label))
          else plan
      }
      transform(plan)
    }

    // ----- Generating trees from plans ---------------

    /** The condition a test plan rewrites to */
    private def emitCondition(plan: TestPlan): Tree = {
      val scrutinee = plan.scrutinee
      plan.test match {
        case NonEmptyTest =>
          scrutinee
            .select(nme.isEmpty, _.info.isParameterless)
            .select(nme.UNARY_!, _.info.isParameterless)
        case NonNullTest =>
          scrutinee.testNotNull
        case GuardTest =>
          scrutinee
        case EqualTest(tree) =>
          tree.equal(scrutinee)
        case LengthTest(len, exact) =>
          scrutinee
            .select(defn.Seq_lengthCompare.matchingMember(scrutinee.tpe))
            .appliedTo(Literal(Constant(len)))
            .select(if (exact) defn.Int_== else defn.Int_>=)
            .appliedTo(Literal(Constant(0)))
        case TypeTest(tpt) =>
          val expectedTp = tpt.tpe

          // An outer test is needed in a situation like  `case x: y.Inner => ...`
          def outerTestNeeded: Boolean = {
            // See the test for SI-7214 for motivation for dealias. Later `treeCondStrategy#outerTest`
            // generates an outer test based on `patType.prefix` with automatically dealises.
            expectedTp.dealias match {
              case tref @ TypeRef(pre: SingletonType, name) =>
                tref.symbol.isClass &&
                ExplicitOuter.needsOuterIfReferenced(tref.symbol.asClass)
              case _ =>
                false
            }
          }

          def outerTest: Tree = trans.transformFollowingDeep {
            val expectedOuter = singleton(expectedTp.normalizedPrefix)
            val expectedClass = expectedTp.dealias.classSymbol.asClass
            ExplicitOuter.ensureOuterAccessors(expectedClass)(ctx.withPhase(ctx.explicitOuterPhase.next))
            scrutinee.ensureConforms(expectedTp)
              .outerSelect(1, expectedOuter.tpe.widen)
              .select(defn.Object_eq)
              .appliedTo(expectedOuter)
          }

          expectedTp.dealias match {
            case expectedTp: SingletonType =>
              scrutinee.isInstance(expectedTp)  // will be translated to an equality test
            case _ =>
              val typeTest = scrutinee.select(defn.Any_typeTest).appliedToType(expectedTp)
              if (outerTestNeeded) typeTest.and(outerTest) else typeTest
          }
      }
    }

    /** Collect longest list of plans that represent possible cases of
     *  a switch, including a last default case, by starting with this
     *  plan and following onSuccess plans.
     */
    private def collectSwitchCases(plan: TestPlan): List[Plan] = {
      def isSwitchableType(tpe: Type): Boolean =
        (tpe isRef defn.IntClass) ||
        (tpe isRef defn.ByteClass) ||
        (tpe isRef defn.ShortClass) ||
        (tpe isRef defn.CharClass)

      val scrutinee = plan.scrutinee

      def isIntConst(tree: Tree) = tree match {
        case Literal(const) => const.isIntRange
        case _ => false
      }

      def recur(plan: Plan): List[Plan] = plan match {
        case TestPlan(EqualTest(tree), scrut, _, _, onf)
        if scrut === scrutinee && isIntConst(tree) =>
          plan :: recur(onf)
        case _ =>
          plan :: Nil
      }

      recur(plan)
    }

    /** Emit cases of a switch */
    private def emitSwitchCases(cases: List[Plan]): List[CaseDef] = (cases: @unchecked) match {
      case TestPlan(EqualTest(tree), _, _, ons, _) :: cases1 =>
        CaseDef(tree, EmptyTree, emit(ons)) :: emitSwitchCases(cases1)
      case (default: Plan) :: Nil =>
        CaseDef(Underscore(defn.IntType), EmptyTree, emit(default)) :: Nil
    }

    /** If selfCheck is `true`, used to check whether a tree gets generated twice */
    private val emitted = mutable.Set[Int]()

    /** Translate plan to tree */
    private def emit(plan: Plan): Tree = {
      if (selfCheck) {
        assert(plan.isInstanceOf[CallPlan] || !emitted.contains(plan.id), plan.id)
        emitted += plan.id
      }
      plan match {
        case plan: TestPlan =>
          val switchCases = collectSwitchCases(plan)
          if (switchCases.lengthCompare(4) >= 0) // at least 3 cases + default
            Match(plan.scrutinee, emitSwitchCases(switchCases))
          else
            If(emitCondition(plan).withPos(plan.pos), emit(plan.onSuccess), emit(plan.onFailure))
        case plan @ LetPlan(sym, body) =>
          val symDef =
            if (sym.is(Label)) DefDef(sym, emit(labelled(sym)))
            else ValDef(sym, rhs(sym).ensureConforms(sym.info))
          seq(symDef :: Nil, emit(body))
        case CodePlan(tree) =>
          tree
        case CallPlan(label) =>
          ref(label).ensureApplied
      }
    }

    /** Pretty-print plan; used for debugging */
    def show(plan: Plan): String = {
      val refCount = referenceCount(plan)
      val sb = new StringBuilder
      val seen = mutable.Set[Int]()
      def showTest(test: Test) = test match {
        case EqualTest(tree) => i"EqualTest($tree)"
        case TypeTest(tpt) => i"TypeTest($tpt)"
        case _ => test.toString
      }
      def showPlan(plan: Plan): Unit =
        if (!seen.contains(plan.id)) {
          seen += plan.id
          sb append s"\n${plan.id}: "
          plan match {
            case TestPlan(test, scrutinee, _, ons, onf) =>
              sb.append(i"${showTest(test)}(${ons.id}, ${onf.id})")
              showPlan(ons)
              showPlan(onf)
            case LetPlan(sym, body) =>
              val rhsStr = binding(sym) match {
                case tree: Tree @unchecked => tree.show
                case plan: Plan => plan.id.toString
              }
              sb.append(s"Let($sym = $rhsStr}, ${body.id})")
              sb.append(s", refcount = ${refCount(sym)}")
              showPlan(body)
              binding(sym) match {
                case tree: Tree @unchecked =>
                case plan: Plan => showPlan(plan)
              }
            case CodePlan(tree) =>
              sb.append(tree.show)
            case CallPlan(label) =>
              sb.append(s"Call($label)")
          }
        }
      showPlan(plan)
      sb.toString
    }

    /** If match is switch annotated, check that it translates to a switch
     *  with at least as many cases as the original match.
     */
    private def checkSwitch(original: Match, result: Tree) = original.selector match {
      case Typed(_, tpt) if tpt.tpe.hasAnnotation(defn.SwitchAnnot) =>
        val resultCases = result match {
          case Match(_, cases) => cases
          case Block(_, Match(_, cases)) => cases
          case _ => Nil
        }
        if (resultCases.length < original.cases.length)
          ctx.warning(s"could not emit switch for @switch annotated match", original.pos)
      case _ =>
    }

    /** Translate pattern match to sequence of tests. */
    def translateMatch(tree: Match): Tree = {
      val unoptimized = matchPlan(tree)
      patmatch.println(i"Plan for $tree:${show(unoptimized)}")
      val optimized = optimize(unoptimized)
      patmatch.println(s"Optimized: ${show(optimized)}")
      val result = emit(optimized)
      checkSwitch(tree, result)
      result
    }
  }
}
